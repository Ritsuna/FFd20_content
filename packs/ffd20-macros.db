{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","type":"script","scope":"global","command":"game.ffd20.rollDefenses();","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/items/armor/shield-light-metal.png","actorIds":[]}
{"name":"Travel Time Calculations","type":"script","scope":"global","command":"/**\n * Travel Calculator for planning extended trips, or just to see the travel time.\n *\n * TODO/PLANs:\n * - Decide if NOT hustling is better in case the removal of a break it causes gets you farther.\n *   - Forced march may be more useful\n * - Output to share with the rest of the players.\n * - Breaks during travel to heal damage (using available idle time) to mitigate damage.\n * - Late start on travel (lost available hours for single day).\n * - Travel interruption based on distance or time, including status of the party at the time of interruption.\n * - Last push option. Risk everything.\n *\n * NOTES:\n * - 24 hour clock is used.\n * - Default rest period of 11 hours assumes party size of 4 with reasonable watch cycling and full rest for all.\n *\n * Built-in camping times based on party size are based on info from PF2e: https://2e.aonprd.com/Rules.aspx?ID=534\n * The same logic works for PF1 so there was no reason to make something custom.\n *\n * COMPATIBILITY:\n * - Foundry VTT 0.7.x\n * - Pathfinder 0.77.24\n *\n * FVTT 0.8.x compatibility should be unaffected.\n * */\n\n'use strict'; // remove this line if using Furnace\n\nclass TravelOptions {\n\t/**\n\t * Delay healing based on these criteria to ensure maximal healing and as little time is spent on bad breaks.\n\t */\n\tstatic healingThresholdFlat = 4; // minimum damage\n\tstatic healingThresholdPercentage = 0.15; // 15% damage at least\n\n\tstatic overlandUnit = 'mi'; // for display purposes only\n\n\tstatic defaultHustling = 3;\n\tstatic defaultForceMarch = 0;\n\n\t/**\n\t * End rest at this hour of the day.\n\t * 5 leads to +1h prep/setup\n\t */\n\tstatic alignRestEnd = 5; // End rest at this hour of the day.\n\t/**\n\t * Hide resting hours. Effectively same as setting resting to 0, except the healing still occurs.\n\t */\n\tstatic displayRest = true;\n\n\tstatic displayRemainingDay = false; // Display remaining day info even if destination is reached\n\n\tstatic combineTravel = true; // combine consecutive travel segments // NOT IMPLEMENTED\n\tstatic combineTravelIdenticalOnly = true; // Combine only near-identical travel segments. // NOT IMPLEMENTED\n\t/**\n\t * Combine camping segments (rest, prep, setup, idle,...).\n\t */\n\tstatic combineCamping = true; // combine consecutive camping segments\n\n\t/**\n\t * Reduce prep duration by setup duration.\n\t */\n\tstatic prepMixedWithSetup = true; // NOT IMPLEMENTED\n\n\t/**\n\t * Setup is divided on both ends of travel.\n\t * Effectively means some characters handle setup while those that need prep do prep.\n\t */\n\tstatic splitSetup = true; // split setup on both sides of travel\n\n\t/**\n\t * Speed multiplier for hustled hours.\n\t * Default: 2\n\t */\n\tstatic hustleSpeed = 2;\n\t/**\n\t * Environmental Damage.\n\t * Default: True\n\t *\n\t * If True: travel damage is treated as environmental damage.\n\t * \t\tThis forces to use actual breaks during travel to mitigate the NL damage.\n\t * If False: you can keep healing it despite accumulating more damage.\n\t * \t\tThis effectively grants free virtual break hour between every hour.\n\t */\n\tstatic envDamage = true; // NOT IMPLEMENTED\n\t/**\n\t * Hours in a day.\n\t * Default: 24\n\t */\n\tstatic dayHours = 24;\n\t/**\n\t * Normal hours available for travel\n\t * Default: 8\n\t *\n\t * Going past this number is force marching.\n\t */\n\tstatic normalTravelHours = 8;\n\t/**\n\t * Default travel speed.\n\t */\n\tstatic normalDailyTravelSpeed = 24;\n\n\tstatic debug = false;\n};\n\n/**\n * Limits to not exceed for any reason.\n */\nclass SafetyOptions {\n\tstatic MaxTravel = 16;\n\tstatic MaxCamping = 20;\n\n\t/**\n\t * Don't rest if damage is less than HD value.\n\t */\n\tstatic NoRestUnderHD = true;\n};\n\nconst signNum = (n) => n < 0 ? `${n}` : `+${n}`;\n\n/**\n * @param {Number} hitDice\n * @param {Number} totalHitPoints\n * @param {Number} damageRemaining\n * @param {TravelInfo} travel\n * @returns {Boolean}\n */\nconst healOrNot = (hitDice, totalHitPoints, damageRemaining, travel) => {\n\tif (SafetyOptions.NoRestUnderHD && damageRemaining < hitDice) return false;\n\tif (damageRemaining < travel.acceptableDamage) return false;\n\tif (damageRemaining > TravelOptions.healingThresholdFlat) return true;\n\tif (damageRemaining > (totalHitPoints * TravelOptions.healingThresholdPercentage)) return true;\n\treturn false;\n}\n\nclass Time {\n\tdays = 0;\n\thours = 0;\n\tminutes = 0;\n\tseconds = 0;\n\n\tstatic get Day() { return 86400; };\n\tstatic get DayCs() { return 864000; };\n\tstatic get Hour() { return 3600; };\n\tstatic get HourCs() { return 36000; };\n\tstatic get Minute() { return 60; };\n\tstatic get MinuteCs() { return 600; };\n\tstatic get Cs() { return 10 };\n\n\tget totalCs() {\n\t\treturn (this.days * Time.DayCs) +\n\t\t\t(this.hours * Time.HourCs) +\n\t\t\t(this.minutes * Time.MinuteCs) +\n\t\t\t(this.seconds * Time.Cs);\n\t}\n\t_totalCs = 0;\n\n\tconstructor({ days = 0, hours = 0, minutes = 0 } = {}) {\n\t\tthis.days = days;\n\t\tthis.hours = hours;\n\t\tthis.minutes = minutes;\n\t}\n\tget totalHours() { return this.hours + (this.minutes / 60) + (this.days * 24) + (this.seconds / 60 / 60); }\n\tget rounded() { return Math.ceil(this.totalHours); }\n\ttoString() {\n\t\tif (this.days > 0)\n\t\t\treturn `${this.days}:${clock(this.hours)}:${clock(this.minutes)}`;\n\t\telse\n\t\t\treturn `${clock(this.hours)}:${clock(this.minutes)}`;\n\t}\n\n\tstatic fromCs(cs) {\n\t\tlet t = new Time();\n\t\tlet r = t._totalCs = cs;\n\t\tt.days = Math.floor(r / 864000);\n\t\tr = r % 864000;\n\t\tt.hours = Math.floor(r / 36000);\n\t\tr = r % 36000;\n\t\tt.minutes = Math.floor(r / 600);\n\t\tr = r % 600;\n\t\tt.seconds = Math.floor(r / 10);\n\t\treturn t;\n\t}\n\n\tredistribute(hours = false) {\n\t\tObject.assign(this, Time.fromCs(this.totalCs));\n\t\tif (hours) {\n\t\t\tthis.hours += this.days * 24;\n\t\t\tthis.days = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Time} time\n\t */\n\tstatic copy(time) { return Object.assign(new Time(), duplicate(time)); }\n}\n\nclass NightWatching {\n\ttotalTime = 0;\n\tperWatch = 0;\n\twatchers = 0;\n\n\tconstructor(watchers, total, perWatch) {\n\t\tthis.watchers = watchers;\n\t\tthis.totalTime = total;\n\t\tthis.perWatch = perWatch;\n\t}\n};\n\nconst nightWatches = {\n\t1: new NightWatching(1, new Time({ hours: 8 }), new Time({ hours: 8 })),\n\t2: new NightWatching(2, new Time({ hours: 16 }), new Time({ hours: 8 })),\n\t3: new NightWatching(3, new Time({ hours: 12 }), new Time({ hours: 4 })),\n\t4: new NightWatching(4, new Time({ hours: 10, minutes: 40 }), new Time({ hours: 2, minutes: 40 })),\n\t5: new NightWatching(5, new Time({ hours: 10 }), new Time({ hours: 2 })),\n\t6: new NightWatching(6, new Time({ hours: 9, minutes: 36 }), new Time({ hours: 1, minutes: 36 }))\n\t// More people don't affect minimum rest without causing fatigue.\n};\n\nconst clampNum3 = (n) => Math.floor(n * 1000) / 1000;\nconst range = (r) => r > 0 ? (new Array(r)).fill().map((_, i) => i + 1) : [];\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst clock = (n) => n < 100 ? (\"00\" + n).slice(-2) : n;\n\n// > deals 1 point of nonlethal damage, and each additional hour deals twice the damage taken during the previous hour of hustling.\n// 1, 2, 3, 4, 5,  6,  7,  8,   9,  10\nconst hustleDmg = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024];\nconst hustleHour = (h) => hustleDmg[h - 1];\nconst hustleCumulative = (h) => hustleDmg.slice(0, h).reduce((c, x) => x + c, 0);\nconst forceMarch = (hours) => {\n\treturn { time: hours, formula: '(@fm) d6' };\n};\nconst forceMarchCheckDC = (hour) => 10 + 2 * (hour - 1);\n\nclass TravelInfo {\n\tidle = 0;\n\tdistance = 250;\n\tmultiplier = 1;\n\tterrainMod = 1;\n\t/**\n\t * Time available for any kind of traveling after all other activities are subtracted. Not counting forced march.\n\t */\n\tavailableTravelHours = 8; // base based on other info\n\t/**\n\t * Total actual hours spent traveling. This includes normal travel hours and planned forced march.\n\t */\n\tget dailyHoursPlan() { return this.availableTravelHours + this.forcedMarch; }\n\t/**\n\t * Available travel hours + Hustle effect as planned.\n\t */\n\tget dailyHoursEffectivePlan() { return this.dailyHoursPlan + this.hustle; } // hours traveling total, effective, including bonus from hustle\n\n\tforcedMarch = TravelOptions.defaultForceMarch; // hours forced marching\n\tforcedMarchActual = 0;\n\thustle = TravelOptions.defaultHustling; // hours hustling\n\tbreaks = 0;\n\tacceptableDamage = 0;\n\tminimumDamage = 0;\n\tdailyMaxDamage = null;\n\tdailyMinDamage = null;\n\n\tfullDays = 0;\n\tremainderFromFullDays = 0;\n\tremainder = 0;\n\tdestinationReached = false;\n\n\tdailyDistance = TravelOptions.normalDailyTravelSpeed;\n\thourlyDistance = 0;\n\ttotalTravelTime = new Time();\n\tdailyNaturalHealing = 0;\n\n\tabandonedTravel = 0;\n\n\t/**\n\t * @param {TravelInfo} travel\n\t */\n\tstatic copy(travel) {\n\t\tconst b = Object.assign(new TravelInfo(), duplicate(travel));\n\t\tb.totalTravelTime = Time.copy(b.totalTravelTime); // fix type\n\t\treturn b;\n\t}\n\n\tsanitize() {\n\t\t//this.idle = Math.max(0, this.idle);\n\t\tthis.distance = Math.max(0, this.distance);\n\t\tthis.multiplier = Math.max(0, this.multiplier);\n\t\tthis.hustle = Math.max(0, this.hustle);\n\t\tthis.breaks = Math.max(0, this.breaks);\n\t\tthis.forcedMarch = Math.max(0, this.forcedMarch);\n\t}\n}\n\nclass CampingData {\n\tother = 0; // Any other time\n\tsetup = 1; // Total time to set up and break down a camp.\n\tresting = 11; // Time spent resting, total, including watches.\n\tpreparing = 0; // prepare spells and such\n\tget total() { return this.other + this.setup + this.resting + this.preparing; }\n\n\t/**\n\t * @param {CampingData} camp\n\t */\n\tstatic copy(camp) {\n\t\treturn Object.assign(new CampingData(), duplicate(camp));\n\t}\n\n\tsanitize() {\n\t\tthis.other = Math.max(0, this.other);\n\t\tthis.setup = Math.max(0, this.setup);\n\t\tthis.resting = Math.max(0, this.resting);\n\t\tthis.preparing = Math.max(0, this.preparing);\n\t}\n}\n\nclass PartyInfo {\n\t/**\n\t * Party size\n\t * Affects resting period.\n\t */\n\tsize = 4;\n\t/**\n\t * Hit Points\n\t * Capacity for damage before travel becomes impossible.\n\t */\n\thitPoints = 10;\n\t/**\n\t * Hit Dice\n\t * Natural healing.\n\t */\n\thitDice = 1;\n\t/**\n\t * Fast Healing\n\t */\n\tfastHeal = 0;\n\t/**\n\t * Overland movement speed.\n\t */\n\tspeedOverland = 24;\n\t/**\n\t * Actual overland movement speed with speed multiplier applied.\n\t */\n\tspeedOverlandActual = 24;\n\t/**\n\t * Tactical movement speed. For easy conversion to overland speed.\n\t */\n\tspeedTactical = 30;\n\n\t/**\n\t * @param {PartyInfo} party\n\t */\n\tstatic copy(party) {\n\t\treturn Object.assign(new PartyInfo(), duplicate(party));\n\t}\n\n\tsanitize() {\n\t\tthis.hitDice = Math.max(1, this.hitDice);\n\t\tthis.hitPoints = Math.max(1, this.hitPoints);\n\t\tthis.speedTactical = Math.max(5, this.speedTactical);\n\t\tthis.speedOverland = this.speedTactical * 0.8;\n\t}\n}\n\n// Activity enum\nconst Activity = { Travel: 'travel', Rest: 'rest', Break: 'break', Preparation: 'preparation', Setup: 'setup', Idle: 'idle', Other: 'other', Start: 'start', Destination: 'destination' };\nconst ActIcons = {\n\thustle: 'fas fa-running',\n\ttravel: 'fas fa-hiking',\n\trest: 'fas fa-bed',\n\tbreak: 'fas fa-mug-hot', // 'fas fa-beer', 'fas fa-coffee'\n\tpreparation: 'fas fa-book-reader',\n\tsetup: 'fas fa-campground',\n\tidle: 'fas fa-battery-empty',\n\tother: 'fas fa-drumstick-bite',\n\tstart: 'fas fa-route',\n\tdestination: 'fas fa-flag-checkered', // 'fas fa-place-of-worship'\n\tforce: 'fas fa-lungs',\n\thurt: 'fas fa-band-aid',\n\tthinking: 'fas fa-sign',\n\tinjury: 'fas fa-heart-broken',\n};\n\nconst randomMapSymbols = [\n\t'fas fa-map-signs', //\n\t'fas fa-drafting-compass',\n];\n\nconst randomPainSymbols = [\n\t'far fa-sad-cry',\n\t'far fa-sad-tear',\n];\n\nclass TimeSegment {\n\tindex = 0;\n\t/**\n\t * Distance covered by this segmnet.\n\t */\n\tdistance = 0;\n\tdistanceTotal = 0;\n\t/**\n\t * Time spent on this segment.\n\t */\n\ttime = 1;\n\ttimeTotal = 0;\n\t/**\n\t * Activity for the time segment.\n\t */\n\tactivity = Activity.Rest;\n\tget isCamping() { return [Activity.Break, Activity.Rest, Activity.Setup, Activity.Idle, Activity.Other].includes(this.activity); }\n\tget isTravel() { return [Activity.Travel].includes(this.activity); }\n\n\thealthAdjust = 0;\n\thealthTotal = 0;\n\n\thustle = false;\n\thustleTotal = 0;\n\tforced = false;\n\tforcedTotal = 0;\n\n\tconstructor(time = 1, distance = 0) {\n\t\tthis.time = time;\n\t\tthis.distance = distance;\n\t}\n\n\theal(hp) {\n\t\tthis.healthAdjust += hp;\n\t\tthis.healthTotal = Math.min(0, this.healthTotal + hp);\n\t}\n\n\t/**\n\t * @param {TimeSegment} sg\n\t */\n\tstatic copy(sg) {\n\t\treturn Object.assign(new TimeSegment(), duplicate(sg));\n\t}\n}\n\nclass TravelLog {\n\t/**\n\t * @type {TimeSegment[]}\n\t */\n\tsegments = [];\n\t/**\n\t * @type {PartyInfo}\n\t */\n\tparty;\n\t/**\n\t * @type {CampingData}\n\t */\n\tcamp;\n\t/**\n\t * @type {TravelInfo}\n\t */\n\ttravel;\n\n\t/**\n\t * Travel distance based on segment info.\n\t */\n\tget travelDistance() {\n\t\treturn this.segments.reduce((a, x) => a + x.distance, 0);\n\t}\n\t/**\n\t * Total time based on segment info.\n\t */\n\tget totalTime() {\n\t\treturn this.segments.reduce((a, x) => a + x.time, 0);\n\t}\n\t/**\n\t * Total time based on segment info up to reaching destination.\n\t */\n\tget finalDayTime() {\n\t\tlet time = 0;\n\t\tfor (let i = 0; i < this.segments.length; i++) {\n\t\t\ttime += this.segments[i].time;\n\t\t\tif (this.segments[i].activity === Activity.Destination) break;\n\t\t}\n\t\treturn time;\n\t}\n\n\t/**\n\t * Total health modifier based on segment info.\n\t */\n\tget health() {\n\t\treturn this.segments.reduce((a, x) => a + x.healthAdjust, 0);\n\t}\n\t/**\n\t * All travel segments.\n\t */\n\tget travelSegments() {\n\t\treturn this.segments.filter(s => s.activity === Activity.Travel);\n\t}\n\t/**\n\t * All break segments.\n\t */\n\tget breakSegments() {\n\t\treturn this.segments.filter(s => s.activity === Activity.Break);\n\t}\n\t/**\n\t * All rest segments.\n\t */\n\tget restSegments() {\n\t\treturn this.segments.filter(s => s.activity === Activity.Rest);\n\t}\n\n\tget first() {\n\t\treturn this.segments[0];\n\t}\n\n\tget last() {\n\t\treturn this.segments[this.segments.length - 1];\n\t}\n\n\tconstructor(partyInfo, campingData, travelInfo) {\n\t\tthis.party = PartyInfo.copy(partyInfo);\n\t\tthis.camp = CampingData.copy(campingData);\n\t\tthis.travel = TravelInfo.copy(travelInfo);\n\t\tthis.party.sanitize();\n\t\tthis.camp.sanitize();\n\t\tthis.travel.sanitize();\n\t}\n\n\t/**\n\t * @param {Boolean} push Calculate as if doing final push, risking yourself to get as much as possible of the time available. // Not implemented\n\t */\n\tcalculate(push = false) {\n\t\tthis.travel.forcedMarchActual = 0;\n\n\t\tthis.travel.hourlyDistance = this.party.speedOverlandActual / TravelOptions.normalTravelHours;\n\t\tthis.travel.idle = TravelOptions.dayHours - (this.camp.total + this.travel.dailyHoursPlan);\n\n\t\tlet hustlingLeft = this.travel.hustle;\n\t\tlet curHustleHours = 0;\n\t\tlet nonFM = this.travel.availableTravelHours;\n\t\tlet remainingDistance = this.travel.distance;\n\t\tthis.travel.abandonedTravel = 0;\n\t\tlet totalDamage = 0;\n\n\t\tthis.travel.dailyNaturalHealing = 0;\n\t\tthis.travel.breaks = 0;\n\n\t\tlet breaksLeft = this.travel.breaks;\n\n\t\tconst hDmg = hustleCumulative(this.travel.hustle);\n\t\tconst fmDmg = forceMarch(this.travel.forcedMarch);\n\t\tconst formula = `${hDmg}+${fmDmg.formula}`;\n\t\tconst rollMax = new Roll(formula, { fm: this.travel.forcedMarch }).evaluate({ maximize: true });\n\t\tconst rollMin = new Roll(formula, { fm: this.travel.forcedMarch }).evaluate({ minimize: true });\n\t\tthis.travel.dailyMaxDamage = rollMax;\n\t\tthis.travel.dailyMinDamage = rollMin;\n\n\t\tconst breakStop = (hp) => {\n\t\t\tconst sg = new TimeSegment(1);\n\t\t\tsg.activity = Activity.Break;\n\t\t\tsg.healthTotal = hp;\n\t\t\tsg.heal(this.party.hitDice);\n\t\t\treturn sg;\n\t\t}\n\n\t\t/**\n\t\t * @param {TimeSegment} sg\n\t\t */\n\t\tconst tryHeal = (sg) => {\n\t\t\tlet damage = -totalDamage;\n\t\t\twhile (this.travel.idle > 0 && healOrNot(this.party.hitDice, this.party.hitPoints, damage, this.travel)) {\n\t\t\t\tlet upcomingDamage = 0;\n\t\t\t\tif (hustlingLeft > 0) {\n\t\t\t\t\tupcomingDamage = hustleHour(curHustleHours + 1);\n\t\t\t\t}\n\t\t\t\tif ((damage + upcomingDamage) < this.travel.acceptableDamage)\n\t\t\t\t\tbreak;\n\n\t\t\t\tconst b = breakStop(-damage);\n\t\t\t\ttotalDamage = b.healthTotal;\n\n\t\t\t\tthis.travel.breaks++;\n\t\t\t\tthis.travel.idle--;\n\n\t\t\t\tthis.segments.push(b);\n\t\t\t\tthis.travel.dailyNaturalHealing += b.healthAdjust;\n\t\t\t\tdamage = Math.max(0, damage - b.healthAdjust);\n\t\t\t}\n\t\t};\n\n\t\tconst fillTime = (r, activity, time = 1) => {\n\t\t\trange(r).forEach(_ => {\n\t\t\t\tconst s = new TimeSegment(time);\n\t\t\t\ts.activity = activity;\n\t\t\t\ts.healthAdjust = this.party.hitDice;\n\t\t\t\tthis.segments.push(s);\n\t\t\t});\n\t\t};\n\n\t\tfillTime(this.camp.resting, Activity.Rest);\n\t\tfillTime(this.camp.preparing, Activity.Preparation);\n\t\tfillTime(this.camp.setup, Activity.Setup);\n\n\t\tconst travelStart = this.segments.length - 1;\n\n\t\trange(this.travel.dailyHoursPlan).forEach(i => {\n\t\t\tif (remainingDistance <= 0) {\n\t\t\t\tthis.travel.abandonedTravel++;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst sg = new TimeSegment(1);\n\t\t\tsg.index = i;\n\t\t\tsg.hustle = (hustlingLeft-- > 0);\n\t\t\tsg.distance = this.travel.hourlyDistance * (sg.hustle ? TravelOptions.hustleSpeed : 1);\n\t\t\tremainingDistance -= sg.distance;\n\t\t\tsg.activity = Activity.Travel;\n\t\t\tsg.healthAdjust = Math.min(0, sg.hustle ? -hustleHour(++curHustleHours) : 0);\n\t\t\ttotalDamage = Math.min(0, totalDamage + sg.healthAdjust); // Can't overheal\n\t\t\tsg.healthTotal = totalDamage;\n\t\t\tsg.forced = --nonFM < 0;\n\t\t\tif (sg.forced) this.travel.forcedMarchActual++;\n\t\t\tthis.segments.push(sg);\n\n\t\t\tif (remainingDistance <= 0) {\n\t\t\t\tlet speed = sg.distance;\n\t\t\t\tsg.distance += remainingDistance; // remove overtravel\n\t\t\t\tsg.time = sg.distance / speed;\n\t\t\t\tconst end = new TimeSegment(0);\n\t\t\t\tend.activity = Activity.Destination;\n\t\t\t\tthis.travel.destinationReached = true;\n\t\t\t\tthis.segments.push(end);\n\t\t\t}\n\t\t\telse\n\t\t\t\ttryHeal(sg);\n\t\t});\n\n\t\tconst travelEnd = this.segments.length - 1;\n\n\n\t\tif (TravelOptions.debug) {\n\t\t\tconsole.log(\"IgnoredTravel:\", this.travel.abandonedTravel);\n\t\t\tconsole.log(\"IgnoredBreaks:\", breaksLeft);\n\t\t\tconsole.log(\"OverTravel:\", -remainingDistance);\n\t\t\tconsole.log(\"ForcedMarch:\", this.travel.forcedMarchActual);\n\t\t}\n\t\tthis.travel.remainder = Math.max(0, remainingDistance);\n\n\t\tif (this.travel.remainder > 0 || TravelOptions.displayRemainingDay) {\n\t\t\tfillTime(this.camp.other, Activity.Other);\n\t\t\tfillTime(this.travel.idle, Activity.Idle);\n\t\t}\n\n\t\t// Update HP recovery\n\t\tthis.segments.filter(s => !s.isTravel).forEach(s => s.healthAdjust = this.party.hitDice * s.time);\n\n\t\tthis.travel.dailyDistance = this.travelDistance;\n\t\tthis.travel.fullDays = Math.floor(this.travel.distance / this.travelDistance);\n\t\tthis.travel.remainderFromFullDays = this.travel.distance - (this.travel.fullDays * this.travelDistance);\n\t}\n\n\t/**\n\t * Ensure totals are accurate.\n\t */\n\taccumulate() {\n\t\tlet hp = 0, dst = 0, tm = 0, f = 0, h = 0;\n\t\tfor (let i = 0; i < this.segments.length; i++) {\n\t\t\tconst s = this.segments[i];\n\t\t\ts.index = i;\n\t\t\ts.distanceTotal = (dst += s.distance);\n\t\t\ts.healthTotal = hp = Math.min(0, (hp + s.healthAdjust));\n\t\t\ts.timeTotal = (tm += s.time);\n\t\t\tif (s.forced) s.forcedTotal = ++f;\n\t\t\tif (s.hustle) s.hustleTotal = ++h;\n\t\t}\n\t}\n\n\t/**\n\t * Transform travel log.\n\t * Re-order, split, and combine events.\n\t */\n\ttransform() {\n\t\tthis.accumulate();\n\n\t\t/**\n\t\t * Splits activity around the delimiter activity.\n\t\t * End defines what activity stops the search.\n\t\t * If delimiter is undefined, it pushes the split to the end instead.\n\t\t */\n\t\tconst split = (activity, end, delimiter = [], splitTime = true) => {\n\t\t\tconst desired = this.segments.filter(s => s.activity === activity);\n\t\t\tconst items = desired.length;\n\t\t\tif (items <= 0) return; // nothing to do\n\t\t\t//const time = desired.reduce((t, c) => t + c.time, 0);\n\t\t\tlet reloc = this.segments.length - 1;\n\t\t\tif (delimiter.length) {\n\t\t\t\tfor (; reloc > 0; reloc--) {\n\t\t\t\t\tconst sg = this.segments[reloc];\n\t\t\t\t\tif ([...delimiter, ...end].includes(sg.activity)) {\n\t\t\t\t\t\treloc++; // back up. +1 to get next one after the breaking point, +1 for correcting the --\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet splitCount = Math.ceil(items / 2);\n\t\t\tlet splitWell = splitTime && items % 2 !== 0;\n\t\t\tif (TravelOptions.debug) console.log(\"Split:\", activity, splitCount, splitWell, \"Reloc to:\", reloc);\n\t\t\tif (splitCount > 0 || splitWell) {\n\t\t\t\tif (TravelOptions.debug) console.group(\"Splitting:\", activity);\n\t\t\t\tlet splitIndex = -1;\n\t\t\t\tfor (let i = 0; i < this.segments.length - 1; i++) {\n\t\t\t\t\tconst sg = this.segments[i];\n\n\t\t\t\t\tif (TravelOptions.debug) console.log(\"Testing segment:\", i, sg.activity);\n\n\t\t\t\t\tif (end.includes(sg.activity)) {\n\t\t\t\t\t\tif (TravelOptions.debug) console.log(\"Ending search at:\", i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (splitCount <= 0) continue;\n\t\t\t\t\tif (sg.activity === activity) {\n\t\t\t\t\t\tconst rpl = [];\n\t\t\t\t\t\tlet adjustIndex = false;\n\t\t\t\t\t\tif (splitWell) {\n\t\t\t\t\t\t\tsplitIndex = i;\n\t\t\t\t\t\t\tsg.time /= 2;\n\t\t\t\t\t\t\trpl.push(TimeSegment.copy(sg));\n\t\t\t\t\t\t\tsplitWell = false; // don't do this again\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tadjustIndex = true;\n\n\t\t\t\t\t\t// HACK: Special case for not showing ending setup for the day you reach your destination on.\n\t\t\t\t\t\tif (!(sg.activity === Activity.Setup && this.travel.destinationReached)) {\n\t\t\t\t\t\t\tconst cut = this.segments.splice(i, 1, ...rpl);\n\t\t\t\t\t\t\tif (delimiter.length)\n\t\t\t\t\t\t\t\tthis.segments.splice(reloc, -1, ...cut);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthis.segments.push(...cut);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (adjustIndex) i--;\n\t\t\t\t\t\t--splitCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (TravelOptions.debug) console.groupEnd();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// split singular item\n\t\t\t\tif (TravelOptions.debug) console.log(\"SINGULAR\");\n\t\t\t\tlet nb = null;\n\t\t\t\tif (setup.length % 2 === 0) {\n\t\t\t\t\tconst splitTime = setup[0].time /= 2;\n\t\t\t\t\tnb = TimeSegment.copy(setup[0]);\n\t\t\t\t\tnb.time = setup[0].time = splitTime;\n\t\t\t\t\t// insert at end of travel\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (this.camp.resting > 0)\n\t\t\tsplit(Activity.Rest, [Activity.Travel, Activity.Setup, Activity.Preparation]);\n\n\t\tconst setup = this.segments.filter(s => s.activity === Activity.Setup);\n\t\tif (TravelOptions.splitSetup && setup.length > 0)\n\t\t\tsplit(Activity.Setup, [Activity.Travel], [Activity.Travel]);\n\n\t\tif (TravelOptions.combineCamping) {\n\t\t\tfor (let i = 0; i < this.segments.length; i++) {\n\t\t\t\tconst s = this.segments[i];\n\t\t\t\tif (!s.isCamping) continue;\n\t\t\t\tconst ns = this.segments[i + 1];\n\t\t\t\tif (s.activity === ns?.activity) {\n\t\t\t\t\ts.healthAdjust += ns.healthAdjust;\n\t\t\t\t\ts.distance += ns.distance;\n\t\t\t\t\ts.time += ns.time;\n\t\t\t\t\tthis.segments.splice(i + 1, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Remove remaining activity from a day.\n\t\t */\n\t\tif (this.travel.destinationReached && !TravelOptions.displayRemainingDay) {\n\t\t\tfor (let i = 0; i < this.segments.length - 1; i++) {\n\t\t\t\tconst sg = this.segments[i];\n\t\t\t\tif (sg.activity === Activity.Destination) {\n\t\t\t\t\tthis.segments.splice(i + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.accumulate(); // fix\n\t}\n\n\t/**\n\t * @param {TravelLog} tl\n\t */\n\tstatic copy(tl) {\n\t\tconst day = new TravelLog(tl.party, tl.camp, tl.travel);\n\t\tday.segments = tl.segments.map(x => TimeSegment.copy(x));\n\t\treturn day;\n\t}\n}\n\n// UI elements\n\nconst col = () => $('<div/>').addClass('flexcol');\nconst row = () => $('<div/>').addClass('flexrow').css({ 'vertical-align': 'middle', 'margin-bottom': '2px' });\nconst title = (text) => $('<h2/>').text(text).css({ 'margin-bottom': '5px', flex: '0', 'font-size': '1.3em' }).css(darkRowCss);\nconst subtitle = (text) => $('<h3/>').text(text).css({ flex: '0' });\nconst label = (text) => $('<label/>').text(text).css({ 'line-height': '1.5em' });\nconst slabel = (text) => $('<label/>').text(text).css({ 'line-height': '1.2em' });\nconst input = (value = '', type = 'text', id) => $('<input/>').attr({ type, value, name: id, maxlength: 6 }).addClass('travel-input').css({ flex: '0 0 5em', 'font-weight': 'bold', color: 'black', height: '1.5em' });\nconst tooltip = (j, text) => j.attr({ title: text });\nconst faIcon = (icon) => $('<i/>').addClass(icon).css({ flex: '0 0 1.5em', 'vertical-align': 'middle', 'line-height': '1.5em' }).html('&nbsp;');\nconst hr = () => $('<hr/>').css({ margin: '1px' });\n\nconst tsCss = { 'text-align': 'right', flex: '.2 .5 1.8em' },\n\ttsCss2 = { 'text-align': 'right', flex: '.2 .5 1.2em', 'margin-left': '3px' },\n\tprimeInputCss = { 'background-color': 'rgba(143, 255, 160, 0.20)' },\n\tinterestingDataCss = { 'background-color': 'rgba(255, 230, 50, 0.15)' },\n\tresultCss = { 'background-color': 'rgba(0, 200, 255, 0.25)' },\n\treadOnlyCss = { color: '#090909', 'background-color': 'rgba(255, 250, 210, 0.15)' },\n\tindentCss = { 'margin-left': '1em' },\n\tunderlineCss = { 'border-bottom': '1px dashed rgba(0, 0, 0, 0.2)' },\n\tdarkRowCss = { 'background-color': 'rgba(0, 0, 0, 0.07)' },\n\tdarkerRowCss = { 'background-color': 'rgba(0, 0, 0, 0.15)' };\n\nconst logHeader = () => {\n\treturn row().append(\n\t\tfaIcon(''),\n\t\tslabel('Activity'),\n\t\ttooltip(slabel('HP Δ'), 'Hit point delta (Change).').css(tsCss),\n\t\ttooltip(slabel('HP Σ'), 'Hit point sigma (Cumulative).').css(tsCss),\n\t\tslabel('Dist.').css(tsCss),\n\t\tslabel('Time').css(tsCss2),\n\t)\n\t\t.css({ border: '1px dashed rgba(0,0,0,0.2)', 'margin-bottom': '2px', padding: '2px', 'max-height': '1.5em', height: '1.5em', 'line-height': '1.5em', 'font-weight': 'bold' })\n\t\t.css(darkerRowCss)\n\t\t.addClass('travel-log-item travel-log-header');\n};\n\n/**\n * @param {TimeSegment} s\n */\nconst logEntry = (s) => {\n\tconst sr = [];\n\tconst act = s.hustle ? 'hustle' : s.activity;\n\tsr.push(faIcon(ActIcons[act]));\n\tlet lb = act.capitalize();\n\tif (s.forced) lb += ' [Forced]';\n\tsr.push(slabel(lb));\n\tconst hp = [];\n\tif (s.forced) hp.push('-1d6')\n\tif (s.healthAdjust != 0) hp.push(signNum(s.healthAdjust));\n\tsr.push(slabel(hp.length ? `${hp.join('')}` : ' ').css(tsCss));\n\tsr.push(slabel(`${s.healthTotal}`).css(tsCss));\n\n\tconst clampDist = (d) => Math.floor(d * 100) / 100;\n\tsr.push(slabel(s.distance != 0 ? `${signNum(clampDist(s.distance))}` : ' ').css(tsCss));\n\tconst tt = Time.fromCs(s.time * Time.HourCs);\n\tsr.push(slabel(`${tt.toString()}`).css(tsCss2).css(s.time !== 1 ? { 'font-weight': 'bold' } : {}));\n\treturn row().append(sr)\n\t\t.css({ border: '1px dashed rgba(0,0,0,0.2)', 'margin-bottom': '2px', padding: '2px', 'max-height': '1.5em', height: '1.5em', 'line-height': '1.5em' })\n\t\t.addClass(`travel-log-item travel-log-activity-${s.activity}`);\n}\n\n/**\n * @param {TravelLog} d\n */\nconst logFooter = (d, final) => {\n\tconst sr = [];\n\tsr.push(faIcon('fas fa-equals').css({ 'font-weight': 'bold' }));\n\tsr.push(slabel('')); // empty for alignment\n\tsr.push(slabel('').css(tsCss)); // empty for alignment\n\tconst hp = [];\n\tif (d.travel.forcedMarchActual > 0) hp.push(`-${d.travel.forcedMarchActual}d6`);\n\thp.push(signNum(d.last.healthTotal));\n\tsr.push(slabel(hp.length ? `${hp.join('')}` : ' ').css(tsCss));\n\tsr.push(slabel(d.travelDistance != 0 ? `${d.travelDistance}` : ' ').css(tsCss));\n\tconst tt = Time.fromCs((final ? d.finalDayTime : d.totalTime) * Time.HourCs);\n\ttt.redistribute(true);\n\tsr.push(slabel(tt.days > 0 ? `${clampNum3(tt.totalHours)}h` : tt.toString()).css(tsCss2));\n\treturn row().append(sr)\n\t\t.css({ border: '1px dashed rgba(0,0,0,0.2)', 'margin-bottom': '2px', padding: '2px', height: '1.5em', 'max-height': '1.5em', 'font-weight': 'bold' })\n\t\t.css(darkerRowCss)\n\t\t.addClass('travel-log-item travel-log-footer');\n};\n\n// UI itself\n\nclass TravelDialog extends Dialog {\n\ttravelTimeBase = TravelOptions.normalTravelHours;\n\n\t/**\n\t * @type {PartyInfo}\n\t */\n\tparty = new PartyInfo();\n\t/**\n\t * @type {TravelInfo}\n\t */\n\ttravel = new TravelInfo();\n\t/**\n\t * @type {CampingData}\n\t */\n\tcamp = new CampingData();\n\n\t/**\n\t * @type {TravelLog?}\n\t */\n\tfullDay = null;\n\t/**\n\t * @type {TravelLog?}\n\t */\n\tfinalDay = null;\n\t/**\n\t * @type {TravelLog?}\n\t */\n\tinitialDay = null;\n\n\tjq = null;\n\n\t/**\n\t * @param {PartyInfo} p\n\t * @param {TravelInfo} t\n\t * @param {CampingData} c\n\t */\n\tconstructor(_data, _options, p, t, c) {\n\t\tsuper(_data, _options);\n\t\tthis.party = p;\n\t\tthis.travel = t;\n\t\tthis.camp = c;\n\t\tthis.data.title = 'Travel Calculator';\n\t\tthis.data.buttons = {\n\t\t\t/*\n\t\t\ttravel: {\n\t\t\t\tlabel: 'Travel',\n\t\t\t\ticon: '<i class=\"fas fa-route\"></i>',\n\t\t\t\tcallback: () => { }\n\t\t\t},\n\t\t\t*/\n\t\t\tdismiss: {\n\t\t\t\tlabel: 'Dismiss',\n\t\t\t\ticon: '<i class=\"fas fa-power-off\"></i>',\n\t\t\t},\n\t\t};\n\t\t//this.data.default = 'travel';\n\n\t\tc.resting = nightWatches[clamp(p.size, 1, 6)].totalTime.rounded ?? 11;\n\t\tif (TravelOptions.debug) console.log(\"Party Size:\", p.size, \"Clamped:\", clamp(p.size, 2, 6));\n\t\tconst h =\n\t\t\trow().append(\n\t\t\t\t// SETUP\n\t\t\t\tcol().css({ flex: '0 0 280px' }).append(\n\t\t\t\t\ttitle('Party (weakest link)'),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-dice'),\n\t\t\t\t\t\tlabel('Hit Dice'),\n\t\t\t\t\t\tinput(p.hitDice, 'number', 'hit-dice').attr({ min: 1, max: 40, step: 1 }),\n\t\t\t\t\t),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-heartbeat'),\n\t\t\t\t\t\tlabel('Hit Points'),\n\t\t\t\t\t\tinput(p.hitPoints, 'number', 'hit-points').attr({ min: 1, max: 500, step: 1 }),\n\t\t\t\t\t),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-shoe-prints'),\n\t\t\t\t\t\tlabel('Tactical speed'),\n\t\t\t\t\t\tinput(p.speedTactical, 'number', 'speed-tactical').attr({ min: 1, step: '.1' }),\n\t\t\t\t\t),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-sleigh'),\n\t\t\t\t\t\tlabel('Overland speed'),\n\t\t\t\t\t\tinput(p.speedOverland, 'number', 'speed-overland').attr({ min: 1, step: '.1' }),\n\t\t\t\t\t),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('fas fa-mountain'),\n\t\t\t\t\t\tlabel('Speed multiplier').css(underlineCss),\n\t\t\t\t\t\tinput(t.multiplier, 'number', 'speed-multiplier').attr({ step: '.01' }),\n\t\t\t\t\t), 'Speed multiplier that affects the entire journey.'),\n\t\t\t\t\ttitle('Journey'),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-route'),\n\t\t\t\t\t\tlabel('Distance'),\n\t\t\t\t\t\tinput(t.distance, 'number', 'distance').attr({ min: 1, step: '.01' }).css(primeInputCss),\n\t\t\t\t\t),\n\t\t\t\t\t/*\n\t\t\t\t\t// NOT IMPLEMENTED\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('far fa-tired'),\n\t\t\t\t\t\tlabel('Acceptable damage').css(underlineCss),\n\t\t\t\t\t\tinput(Math.floor(p.hitPoints / 2), 'number', 'acceptable-damage').attr({ min: 0, max: 500, step: 1 }),\n\t\t\t\t\t), 'Maximum damage allowed to accumulate at any point.'),\n\t\t\t\t\t*/\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.force),\n\t\t\t\t\t\tlabel('Force march').css(underlineCss),\n\t\t\t\t\t\tinput(t.forcedMarch, 'number', 'force-march').attr({ min: 0, max: 22, step: 1 }),\n\t\t\t\t\t), 'Hours to force march per day over the normal daily travel hours.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.hustle),\n\t\t\t\t\t\tlabel('Hustle').css(underlineCss),\n\t\t\t\t\t\tinput(t.hustle, 'number', 'hustle').attr({ min: 0, max: 12, step: 1 }),\n\t\t\t\t\t), 'Hours to hustle per day.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('fas fa-user-injured'),\n\t\t\t\t\t\tlabel('Daily damage').css(underlineCss),\n\t\t\t\t\t\tinput('0', 'text', 'damage-daily').attr({ min: 0, step: 1 }).css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t), 'Nonlethal damage accumulated over the entire day.'),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tlabel(' – Range').css(indentCss),\n\t\t\t\t\t\tinput('0', 'text', 'damage-daily-range').css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.hurt),\n\t\t\t\t\t\tlabel('Acceptable damage').css(underlineCss),\n\t\t\t\t\t\tinput('10', 'number', 'acceptable-damage').attr({ min: '0', step: '1' })\n\t\t\t\t\t), 'Amount of damage not attempted to heal during travel.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tlabel('Daily healing'),\n\t\t\t\t\t\tinput('0', 'text', 'daily-healing')\n\t\t\t\t\t), 'Semicolon separated list of available healing options.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.break),\n\t\t\t\t\t\tlabel('Breaks').css(underlineCss),\n\t\t\t\t\t\tinput(t.breaks, 'number', 'daily-breaks').css(readOnlyCss, interestingDataCss).addClass('readonly')\n\t\t\t\t\t), 'Hours spent resting during travel, including watches and other activities.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('fas fa-hourglass-half'),\n\t\t\t\t\t\tlabel('Travel hours per day').css(underlineCss),\n\t\t\t\t\t\tinput(t.dailyHoursPlan, 'number', 'daily-travel-time').attr({ min: 0, step: '.1' }).css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t), 'Total time used per day for travel.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tlabel(' – Effective:').css(indentCss).css(underlineCss),\n\t\t\t\t\t\tinput(t.dailyHoursPlan, 'number', 'daily-travel-time-effective').attr({ min: 0, step: '.1' }).css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t), 'Includes hustling.'),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon(ActIcons.travel),\n\t\t\t\t\t\tlabel('Travel distance per day'),\n\t\t\t\t\t\tinput(t.dailyDistance, 'number', 'daily-distance').attr({ min: 0, step: '.001' }).css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('fas fa-hourglass-end'),\n\t\t\t\t\t\tlabel('Hours to destination'),\n\t\t\t\t\t\tinput('0', 'text', 'hours-to-destination').css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t), 'Total time to destination, mostly as hours. Format is HHH:MM.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('far fa-calendar-alt'),\n\t\t\t\t\t\tlabel('Days to destination'),\n\t\t\t\t\t\tinput('0', 'text', 'time-to-destination').css(readOnlyCss).addClass('readonly').css(resultCss)\n\t\t\t\t\t), 'Total time to destination. Format is DD:HH:MM'),\n\t\t\t\t\ttitle('Camping'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon('fas fa-users'),\n\t\t\t\t\t\tlabel('Party size'),\n\t\t\t\t\t\tinput(p.size, 'number', 'party-size').attr({ min: 1, max: 24, step: 1 })\n\t\t\t\t\t), 'Adjusting party size auto-calculates needed resting to be appropriate to allow full rest for all.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.rest),\n\t\t\t\t\t\tlabel('Resting').css(underlineCss),\n\t\t\t\t\t\tinput(c.resting, 'number', 'resting').attr({ min: 0, max: 24, step: '.1' }).css(primeInputCss)\n\t\t\t\t\t), 'Total sleep, including any necessary watch time.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.preparation),\n\t\t\t\t\t\tlabel('Preparation').css(underlineCss),\n\t\t\t\t\t\tinput(c.preparing, 'number', 'preparation').attr({ min: 0, max: 24, step: '.1' })\n\t\t\t\t\t), 'Preparing spells and such. Set to zero if this can overlap with setup time.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.setup),\n\t\t\t\t\t\tlabel('Setup').css(underlineCss),\n\t\t\t\t\t\tinput(c.setup, 'number', 'setup').attr({ min: 0, max: 4, step: '.1' })\n\t\t\t\t\t), 'Time to set and break camp and similar activities.'),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.other),\n\t\t\t\t\t\tlabel('Other').css(underlineCss),\n\t\t\t\t\t\tinput(c.other, 'number', 'other').attr({ min: 0, max: 8, step: '.1' })\n\t\t\t\t\t), 'Base necessities of life and other activities.'),\n\t\t\t\t\trow().append(\n\t\t\t\t\t\tfaIcon('fas fa-cloud-sun'),\n\t\t\t\t\t\tlabel('Total'),\n\t\t\t\t\t\tinput(c.total, 'number', 'total-camping').attr({ min: 0, step: '.1' }).css(readOnlyCss).addClass('readonly')\n\t\t\t\t\t),\n\t\t\t\t\ttooltip(row().append(\n\t\t\t\t\t\tfaIcon(ActIcons.idle),\n\t\t\t\t\t\tlabel('Idle').css(underlineCss),\n\t\t\t\t\t\tinput('0', 'number', 'idle').css(readOnlyCss, interestingDataCss).addClass('readonly')\n\t\t\t\t\t), 'Time not used by anything specific and thus available for extra force marching or other activities.'),\n\t\t\t\t),\n\t\t\t\tcol().css({ flex: '0 1 7px' }),\n\t\t\t\tcol().css({ flex: '1' }).addClass('travel-log')\n\t\t\t\t\t.append(\n\t\t\t\t\t\ttitle('Travel Log'),\n\t\t\t\t\t\trow().append(\n\t\t\t\t\t\t\tcol().addClass('travel-log-initial'),\n\t\t\t\t\t\t\tcol().css({ flex: '0 1 5px' }).addClass('travel-log-initial-separator'),\n\t\t\t\t\t\t\tcol().addClass('travel-log-fullday'),\n\t\t\t\t\t\t\tcol().css({ flex: '0 1 5px' }).addClass('travel-log-final-separator'),\n\t\t\t\t\t\t\tcol().addClass('travel-log-final')\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t);\n\n\t\tthis.data.content = $('<div/>').append(h, hr()).html();\n\t}\n\n\tstatic open({ c = new CampingData(), t = new TravelInfo(), p = new PartyInfo() } = {}) {\n\t\tnew TravelDialog({}, { width: 900 }, p, t, c).render(true);\n\t}\n\n\t_updateDialog() {\n\t\tif (!this.fullDay) return;\n\n\t\t// Party\n\t\tthis.jq.find('input[name=\"hit-dice\"]').val(this.party.hitDice);\n\t\tthis.jq.find('input[name=\"hit-points\"]').val(this.party.hitPoints);\n\t\tthis.jq.find('input[name=\"speed-tactical\"]').val(this.party.speedTactical);\n\t\tthis.jq.find('input[name=\"speed-overland\"]').val(this.party.speedOverland);\n\t\tthis.jq.find('input[name=\"speed-multiplier\"]').val(this.travel.multiplier);\n\n\t\t// Journey\n\t\tthis.jq.find('input[name=\"distance\"]').val(this.travel.distance);\n\t\tthis.jq.find('input[name=\"acceptable-damage\"]').val(this.travel.acceptableDamage);\n\t\tthis.jq.find('input[name=\"force-march\"]').val(this.travel.forcedMarch);\n\t\tthis.jq.find('input[name=\"hustle\"]').val(this.travel.hustle);\n\n\t\tthis.jq.find('input[name=\"damage-daily\"]').val(this.travel.dailyMinDamage?.formula ?? '');\n\t\tthis.jq.find('input[name=\"damage-daily-range\"]').val(`${this.travel.dailyMinDamage?.total ?? 0} - ${this.travel.dailyMaxDamage?.total ?? 0}`);\n\n\t\tthis.jq.find('input[name=\"daily-breaks\"]').val(this.travel.breaks);\n\n\t\tthis.jq.find('input[name=\"daily-travel-time\"]').val(this.travel.dailyHoursPlan);\n\t\tthis.jq.find('input[name=\"daily-travel-time-effective\"]').val(this.travel.dailyHoursEffectivePlan);\n\t\tthis.jq.find('input[name=\"daily-distance\"]').val(this.travel.dailyDistance);\n\n\t\tconst bh = Time.copy(this.fullDay.travel.totalTravelTime);\n\t\tconst hh = Time.copy(bh);\n\t\tbh.redistribute(false);\n\t\thh.redistribute(true);\n\n\t\tthis.jq.find('input[name=\"time-to-destination\"]').val(bh.toString());\n\t\tthis.jq.find('input[name=\"hours-to-destination\"]').val(hh.toString());\n\n\t\t// Camping\n\t\tthis.jq.find('input[name=\"party-size\"]').val(this.party.size);\n\t\tthis.jq.find('input[name=\"resting\"]').val(this.camp.resting);\n\t\tthis.jq.find('input[name=\"preparation\"]').val(this.camp.preparing);\n\t\tthis.jq.find('input[name=\"setup\"]').val(this.camp.setup);\n\t\tthis.jq.find('input[name=\"other\"]').val(this.camp.other);\n\t\tthis.jq.find('input[name=\"total-camping\"]').val(this.camp.total);\n\t\tthis.jq.find('input[name=\"idle\"]').val(this.travel.idle);\n\n\t\t// Update warnings\n\t\tconst idle = this.jq.find('input[name=\"idle\"]');\n\t\tconst idleWarn = idle.parent().find('.travel-idle-time-warning');\n\t\tif (this.travel.idle < 0 && idleWarn.length === 0) {\n\t\t\tidle.before(faIcon('fas fa-exclamation-triangle').addClass('travel-idle-time-warning'));\n\t\t\tidle.css(darkRowCss);\n\t\t}\n\t\telse if (this.travel.idle >= 0) {\n\t\t\tidleWarn?.remove();\n\t\t\tidle.css({ 'background-color': 'rgba(255, 250, 210, 0.15)' });\n\t\t}\n\n\n\t}\n\n\t_updateTravel() {\n\t\tconst availableTimeForBaseTravel = TravelOptions.dayHours - this.camp.total;\n\t\tthis.travel.availableTravelHours = Math.min(TravelOptions.normalTravelHours, availableTimeForBaseTravel);\n\t\tif (TravelOptions.debug) console.log(\"availableTimeForBaseTravel:\", availableTimeForBaseTravel);\n\n\t\tthis._generateSchedule();\n\t\tthis._processSchedule();\n\t\tthis._updateDialog()\n\t}\n\n\t// Build basic schedule\n\t_generateSchedule() {\n\t\tthis.fullDay = new TravelLog(this.party, this.camp, this.travel);\n\t\tthis.fullDay.calculate();\n\t\tthis.fullDay.transform();\n\t\tthis.party = this.fullDay.party;\n\t\tthis.camp = this.fullDay.camp;\n\t\tthis.travel = this.fullDay.travel;\n\t\tif (TravelOptions.debug) console.log(\"Remaining distance for final day:\", this.travel.remainderFromFullDays);\n\n\t\tthis.finalDay = new TravelLog(this.fullDay.party, this.fullDay.camp, this.fullDay.travel);\n\t\tthis.finalDay.travel.distance = this.fullDay.travel.remainderFromFullDays;\n\t\tthis.finalDay.calculate();\n\t\tthis.finalDay.transform();\n\t}\n\n\t_processSchedule() {\n\t\tif (!this.fullDay) return;\n\t\tconst day = this.fullDay;\n\t\tconst final = this.finalDay;\n\n\t\t// Re-update output\n\t\tconst p_hours = day.totalTime * day.travel.fullDays;\n\t\tconst f_hours = final?.finalDayTime ?? 0;\n\t\tday.travel.totalTravelTime = Time.fromCs((p_hours + f_hours) * Time.HourCs);\n\n\t\tthis._renderSchedule();\n\t}\n\n\t_renderSchedule() {\n\t\tif (!this.fullDay) return;\n\t\tconst day = this.fullDay;\n\t\tconst fday = this.finalDay;\n\t\tif (TravelOptions.debug) {\n\t\t\tconsole.log(\"FullDay:\", day);\n\t\t\tconsole.log(\"FinalDay:\", fday);\n\t\t}\n\n\t\tconst renderDay = (d, jq, final) => {\n\t\t\tjq.append(logHeader())\n\t\t\td.segments.forEach(s => {\n\t\t\t\tif (s.activity === Activity.Rest && !TravelOptions.displayRest) return;\n\t\t\t\ttry {\n\t\t\t\t\tjq.append(logEntry(s));\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tconsole.warn(d, s);\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t\t//jq.append($('<div/>').css({ flex: '10 2 0px' })); // fillter\n\t\t\tjq.append(logFooter(d, final))\n\t\t}\n\n\t\t// Initial day\n\t\t// NOT IMPLEMENTED\n\t\tconst initCol = this.jq.find('.travel-log-initial');\n\t\tconst initColSep = this.jq.find('.travel-log-initial-separator');\n\t\tconst initial = col().css({ flex: '1' });\n\t\tinitCol.empty().append(subtitle(\"Initial day\"), initial);\n\t\tinitCol.hide();\n\t\tinitColSep.hide();\n\n\t\t// Normal day\n\t\tconst fulldayCol = this.jq.find('.travel-log-fullday');\n\t\tconst fullday = col().css({ flex: '1' });\n\t\tfulldayCol.empty().append(subtitle(`Full day of travel (×${day.travel.fullDays})`), fullday);\n\t\trenderDay(day, fullday);\n\n\t\t// Final day\n\t\tconst finalCol = this.jq.find('.travel-log-final');\n\t\tconst finalColSep = this.jq.find('.travel-log-final-separator');\n\t\tconst final = col().css({ flex: '1' });\n\t\tfinalCol.empty().append(subtitle(\"Final day\"), final);\n\t\tif (fday?.travelDistance > 0) {\n\t\t\trenderDay(fday, final, true);\n\t\t\tfinalCol.show();\n\t\t\tfinalColSep.show();\n\t\t}\n\t\telse {\n\t\t\tfinalCol.hide();\n\t\t\tfinalColSep.hide();\n\t\t}\n\n\t\tfunction alternateRowColors(col) {\n\t\t\tcol.find('div.travel-log-item').not('.travel-log-header').not('.travel-log-footer')\n\t\t\t\t.each(function (i) {\n\t\t\t\t\tif (i % 2 === 0)\n\t\t\t\t\t\t$(this).css(darkRowCss);\n\t\t\t\t});\n\t\t};\n\n\t\talternateRowColors(initCol);\n\t\talternateRowColors(fulldayCol);\n\t\talternateRowColors(finalCol);\n\t}\n\n\t_updateDamage() {\n\t\tconst hDmg = hustleCumulative(this.travel.hustle);\n\t\tconst fmDmg = forceMarch(this.travel.forcedMarch);\n\t\tconst formula = `${hDmg}+${fmDmg.formula}`;\n\n\t\tconst rollMax = new Roll(formula, { fm: this.travel.forcedMarch }).evaluate({ maximize: true });\n\t\tconst rollMin = new Roll(formula, { fm: this.travel.forcedMarch }).evaluate({ minimize: true });\n\n\t\tlet damageRemaining = hDmg;\n\t\tthis.travel.dailyNaturalHealing = 0;\n\t\tthis.travel.breaks = 0;\n\t\twhile (this.travel.idle > 0 && healOrNot(this.party.hitDice, this.party.hitPoints, damageRemaining, this.travel)) {\n\t\t\tthis.travel.breaks++;\n\t\t\tthis.travel.idle--;\n\t\t\tconst adjust = Math.min(damageRemaining, this.party.hitDice);\n\t\t\tdamageRemaining -= adjust;\n\t\t\tthis.travel.dailyNaturalHealing += adjust;\n\t\t}\n\n\t\tconst ddmg = this.jq.find('input[name=\"damage-daily\"]');\n\t\tddmg.val(rollMax.formula);\n\t\tthis.jq.find('input[name=\"damage-daily-range\"]').val(`${rollMin.total} - ${rollMax.total}`);\n\n\t\tconst dmWarn = ddmg.parent().find('.travel-damage-warning');\n\t\tif (rollMin.total > this.travel.acceptableDamage && dmWarn.length === 0)\n\t\t\tddmg.before(faIcon('fas fa-exclamation-triangle').addClass('travel-damage-warning'));\n\t\telse if (rollMin.total < this.travel.acceptableDamage)\n\t\t\tdmWarn?.remove();\n\n\n\t}\n\n\t_updateInputs(ev) {\n\t\tconst name = ev.target.name;\n\t\tconst value = parseFloat(ev.target.value) || 0; // new value\n\t\tif (TravelOptions.debug) console.log('NewValue:', name, '=', value);\n\t\tswitch (name) {\n\t\t\tcase 'hit-dice':\n\t\t\t\tthis.party.hitDice = clamp(Math.round(value), 1, 500);\n\t\t\t\tbreak;\n\t\t\tcase 'hit-points':\n\t\t\t\tthis.party.hitPoints = clamp(Math.round(value), 0, 500000);\n\t\t\t\tthis.travel.acceptableDamage = Math.floor(this.party.hitPoints / 2);\n\t\t\t\tthis.jq.find('input[name=\"acceptable-damage\"]').val(this.travel.acceptableDamage);\n\t\t\t\tbreak;\n\t\t\tcase 'distance':\n\t\t\t\tthis.travel.distance = clamp(value, 0, 50000);\n\t\t\t\tbreak;\n\t\t\tcase 'speed-overland':\n\t\t\t\tthis.party.speedOverland = clamp(value, 1, 500);\n\t\t\t\tthis.party.speedOverlandActual = this.party.speedOverland * this.travel.multiplier;\n\t\t\t\tthis.party.speedTactical = this.party.speedOverland / 0.8;\n\t\t\t\tthis.jq.find('input[name=\"speed-tactical\"]').val(this.party.speedTactical);\n\t\t\t\tbreak;\n\t\t\tcase 'speed-tactical':\n\t\t\t\tthis.party.speedTactical = clamp(value, 5, 500);\n\t\t\t\tthis.party.speedOverland = this.party.speedTactical * 0.8;\n\t\t\t\tthis.party.speedOverlandActual = this.party.speedOverland * this.travel.multiplier;\n\t\t\t\tthis.jq.find('input[name=\"speed-overland\"]').val(this.party.speedOverland);\n\t\t\t\tbreak;\n\t\t\tcase 'speed-multiplier':\n\t\t\t\tthis.travel.multiplier = clamp(value, 0, 10);\n\t\t\t\tthis.party.speedOverlandActual = this.party.speedOverland * this.travel.multiplier;\n\t\t\t\tbreak;\n\t\t\tcase 'acceptable-damage':\n\t\t\t\tthis.travel.acceptableDamage = clamp(value, 0, this.party.hitPoints - 1);\n\t\t\t\tif (value !== this.travel.acceptableDamage)\n\t\t\t\t\tthis.jq.find('input[name=\"acceptable-damage\"]').val(this.travel.acceptableDamage);\n\t\t\t\tbreak;\n\t\t\tcase 'resting':\n\t\t\t\tthis.camp.resting = clamp(value, 0, SafetyOptions.MaxCamping);\n\t\t\t\tbreak;\n\t\t\tcase 'preparation':\n\t\t\t\tthis.camp.preparing = clamp(value, 0, SafetyOptions.MaxCamping);\n\t\t\t\tbreak;\n\t\t\tcase 'setup':\n\t\t\t\tthis.camp.setup = clamp(value, 0, SafetyOptions.MaxCamping);\n\t\t\t\tbreak;\n\t\t\tcase 'other':\n\t\t\t\tthis.camp.other = clamp(value, 0, SafetyOptions.MaxCamping);\n\t\t\t\tbreak;\n\t\t\tcase 'party-size':\n\t\t\t\tthis.party.size = clamp(value, 1, 10);\n\t\t\t\tthis.camp.resting = nightWatches[clamp(this.party.size, 1, 6)].totalTime.rounded ?? 11;\n\t\t\t\tthis.jq.find('input[name=\"resting\"]').val(this.camp.resting);\n\t\t\t\tbreak;\n\t\t\tcase 'hustle':\n\t\t\t\tthis.travel.hustle = clamp(Math.round(value), 0, SafetyOptions.MaxTravel);\n\t\t\t\t{\n\t\t\t\t\tconst evt = $(ev.target);\n\t\t\t\t\tconst hustleWarn = evt.parent().find('.travel-hustle-time-warning');\n\t\t\t\t\tif (this.travel.hustle > this.travel.dailyHoursPlan && hustleWarn.length === 0) {\n\t\t\t\t\t\tevt.before(faIcon('fas fa-exclamation-triangle').addClass('travel-hustle-time-warning'));\n\t\t\t\t\t\tevt.css({ 'background-color': 'rgba(255, 0, 0, 0.1)' });\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.travel.hustle <= this.travel.dailyHoursPlan) {\n\t\t\t\t\t\thustleWarn?.remove();\n\t\t\t\t\t\tevt.css({ 'background-color': '' });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'force-march':\n\t\t\t\tthis.travel.forcedMarch = clamp(Math.round(value), 0, SafetyOptions.MaxTravel);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis._updateTravel();\n\t}\n\n\tactivateListeners(html) {\n\t\tsuper.activateListeners(html);\n\t\tthis.jq = html;\n\t\thtml.find('input.readonly').prop('readonly', true);\n\t\thtml.find('.travel-input').on('change', this._updateInputs.bind(this));\n\t\tthis._updateTravel();\n\t}\n}\n\n{\n\tconst party = new PartyInfo();\n\tif (canvas.tokens.controlled.length > 0) {\n\t\t// Autofill party's weakest link\n\t\tparty.hitPoints = Number.POSITIVE_INFINITY;\n\t\tparty.hitDice = Number.POSITIVE_INFINITY;\n\t\tparty.speedTactical = Number.POSITIVE_INFINITY;\n\t\tparty.size = 0;\n\t\tcanvas.tokens.controlled.map(t => t.actor).forEach(a => {\n\t\t\tif (!a) return;\n\t\t\tparty.size++;\n\t\t\tparty.hitDice = Math.min(a.data.data.attributes.hd.total, party.hitDice);\n\t\t\tparty.hitPoints = Math.min(a.data.data.attributes.hp.value, party.hitPoints);\n\t\t\tparty.speedTactical = Math.min(a.data.data.attributes.speed.land.total, party.speedTactical);\n\t\t});\n\t\tparty.speedOverland = party.speedTactical * 0.8;\n\t\tparty.speedOverlandActual = party.speedOverland;\n\t}\n\n\tTravelDialog.open({ p: party });\n}","author":"3zKQDMDqYUVrixL3","img":"systems/ffd20/icons/ffxiv_icons/FFXIVIcons-MainCommand-(Others)/01_Orders/01/follow.png","actorIds":[],"_id":"3iMelvopLWQtTi9E"}
{"name":"Award XP","type":"script","scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _action = function(xp) {\r\n    if (!isNaN(xp)) {\r\n      actors.forEach(o => {\r\n        let curXP = getProperty(o.data, \"data.details.xp.value\") || 0;\r\n        if (typeof curXP === \"string\") curXP = parseInt(curXP);\r\n        o.update({ \"data.details.xp.value\": curXP + xp });\r\n      });\r\n    }\r\n  };\r\n\r\n  const msg = `Award XP to the following actors: <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n  const field = `<input type=\"text\" name=\"xp\" value=\"0\" placeholder=\"XP amount\" style=\"margin-bottom: 8px;\" />`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>${field}`,\r\n    buttons: {\r\n      ok: {\r\n        label: \"Give All\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          _action(xp);\r\n        },\r\n      },\r\n      distribute: {\r\n        label: \"Distribute\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          xp = Math.floor(xp / actors.length);\r\n          _action(xp);\r\n        }\r\n      }\r\n    },\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"icons/svg/book.svg","actorIds":[],"_id":"8VcUUx7d4TX4WTkt"}
{"name":"Wild Shape","type":"script","scope":"global","command":"// Author: @Adam\r\n\r\n// SETUP NEEDED: for each transformation option you want, please enter it as below\r\n// you also need to set imageFolder to the location of where you store your tokens.\r\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\r\n\r\n// support for elemental body is not complete yet - only air elemental is hardcoded\r\n\r\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\r\n\r\nconst transformationOptions = {\r\n  Bat: {\r\n    size: \"diminutive\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  \"Giant Squid\": {\r\n    size: \"huge\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  Tendriculos: {\r\n    size: \"huge\",\r\n    spellSource: \"plant shape\",\r\n  },\r\n  \"Air Elemental\": {\r\n    size: \"huge\",\r\n    spellSource: \"elemental body\",\r\n  },\r\n};\r\n\r\nconst sizes = [\"diminutive\", \"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"gargantuan\", \"colossal\"];\r\n\r\nconst sizeTranslation = {\r\n  fine: \"fine\",\r\n  diminutive: \"dim\",\r\n  tiny: \"tiny\",\r\n  small: \"sm\",\r\n  medium: \"med\",\r\n  large: \"lg\",\r\n  huge: \"huge\",\r\n  gargantuan: \"grg\",\r\n  colossal: \"col\",\r\n};\r\n\r\nconst createSizeObject = ({ w, h, scale }) => {\r\n  return {\r\n    width: w,\r\n    height: h,\r\n    scale,\r\n  };\r\n};\r\n\r\nconst mediumOrBigger = (size) => {\r\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\r\n};\r\n\r\nconst createAbilityChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ability\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createNACChange = (formula) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ac\",\r\n    subTarget: \"nac\",\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createSpeedChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"speed\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createBuffChanges = (name) => {\r\n  const creature = transformationOptions[name];\r\n  const bulking = mediumOrBigger(creature.size);\r\n  let buffLevel = null;\r\n\r\n  const changes = [];\r\n\r\n  if (bulking) {\r\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\r\n  } else {\r\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\r\n  }\r\n\r\n  switch (creature.spellSource.toLowerCase()) {\r\n    case \"beast shape\": {\r\n      const mainBonus = buffLevel * 2;\r\n      const nacBonus = buffLevel * 2;\r\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\r\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\r\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\r\n\r\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\r\n      changes.push(createAbilityChange(penalty, penaltyAbility));\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"plant shape\": {\r\n      const nacBonus = buffLevel * 2;\r\n      if (bulking) {\r\n        const strBonus = Math.pow(2, buffLevel);\r\n        const conBonus = Math.max(2, buffLevel / 2);\r\n        const penalty = -(buffLevel > 2 ? 2 : 0);\r\n\r\n        changes.push(createAbilityChange(strBonus, \"str\"));\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n        changes.push(createAbilityChange(penalty, \"dex\"));\r\n      } else {\r\n        const conBonus = buffLevel * 2;\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n      }\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"elemental body\": {\r\n      if (name === \"Air Elemental\") {\r\n        changes.push(createAbilityChange(4, \"str\"));\r\n        changes.push(createAbilityChange(6, \"dex\"));\r\n        changes.push(createNACChange(4));\r\n        changes.push(createSpeedChange(120, \"flySpeed\"));\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      ui.notifications.error(\r\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return changes;\r\n};\r\n\r\nconst createWSBuff = async (caster) => {\r\n  const itemData = { type: \"buff\", name: \"Wild Shape (Auto)\", data: { buffType: \"temp\", level: 1 } };\r\n  // Get templates\r\n  await caster.createOwnedItem(itemData);\r\n  return getWSBuff(caster);\r\n};\r\n\r\nconst getWSBuff = (caster) => {\r\n  return caster.items.find(\r\n    (i) =>\r\n    i.type === \"buff\" &&\r\n    i.name === \"Wild Shape (Auto)\"\r\n  );\r\n};\r\n\r\nconst transform = async (caster, token, name) => {\r\n  const creature = transformationOptions[name];\r\n  const changes = createBuffChanges(name);\r\n\r\n  let buff = getWSBuff(caster);\r\n  if (!buff) buff = await createWSBuff(caster);\r\n  buff.update({ \"data.changes\": changes });\r\n  buff.update({ \"data.active\": true });\r\n\r\n  token.update({ img: `${imageFolder}/${name}.png` });\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[sizeTranslation[creature.size]])\r\n  );\r\n  caster.data.data.traits.size = sizeTranslation[creature.size];\r\n};\r\n\r\nconst revertForm = (caster, token) => {\r\n  getWSBuff(caster).update({ \"data.active\": false });\r\n  token.update({ img: caster.data.flags.originalData.image });\r\n  caster.data.data.traits.size = caster.data.flags.originalData.size;\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[caster.data.flags.originalData.size])\r\n  );\r\n};\r\n\r\nconst tokens = canvas.tokens.controlled;\r\n\r\nif (tokens.length !== 1) {\r\n  ui.notifications.warn(\"Select a token.\");\r\n} else {\r\n  const token = tokens[0];\r\n  const actor = token.actor;\r\n  const caster = actor.data;\r\n\r\n  if (!Object.keys(caster.flags).includes(\"originalData\")) {\r\n    const originalData = {\r\n      image: caster.token.img,\r\n      size: caster.data.traits.size,\r\n    };\r\n    caster.flags.originalData = originalData;\r\n  }\r\n\r\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\r\n    label: optionName,\r\n    callback: () => transform(actor, token, optionName),\r\n  }));\r\n  buttons[\"Revert\"] = {\r\n    label: \"Revert\",\r\n    icon: '<i class=\"fas fa-user\"></i>',\r\n    callback: () => revertForm(actor, token),\r\n  };\r\n\r\n  new Dialog({\r\n    title: \"Wild Shape\",\r\n    content: \"Choose creature.\",\r\n    buttons: buttons,\r\n  }).render(true);\r\n}","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/skills/green_27.jpg","actorIds":[],"_id":"GyuHEoeLTtLZCvhS"}
{"name":"Show Actor Information","type":"script","scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const msg = `Choose the information you want to show for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n  \n  new Dialog({\n    title: \"Show Actor Information\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Social Defenses\",\n        callback: () => {\n          let c = \"\";\n          // Add demoralize DC\n          c += `<table><thead><tr><td colspan=\"2\">Demoralize (Intimidate)</td><tr><td>Character</td><td>DC</td></thead><tbody>`;\n          for (let a of actors) {\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dc = 10 + rollData.attributes.hd.total + rollData.abilities.wis.mod;\n            c += `<tr><td>${a.name}</td><td>${dc}</td></tr>`;\n          }\n          c += \"</tbody></table>\";\n          // Add diplomacy DCs\n          c += `<table><thead><tr><td colspan=\"3\">Diplomacy</td></tr><tr><td>Character</td><td>Starting Attitude</td><td>DC</td><thead><tbody>`;\n          for (let a of actors) {\n            c += `<tr><td rowspan=\"5\">${a.name}</td>`;\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dipArr = [{ label: \"Hostile\", base: 25 }, { label: \"Unfriendly\", base: 20 }, { label: \"Indifferent\", base: 15 }, { label: \"Friendly\", base: 10 }, { label: \"Helpful\", base: 0 }];\n            for (let b = 0; b < dipArr.length; b++) {\n              const o = dipArr[b];\n              if (b > 0) c += \"<tr>\";\n              c += `<td>${o.label}</td><td>${o.base + rollData.abilities.cha.mod}</td></tr>`;\n            }\n          }\n          c += \"</tbody></table>\";\n          // Render chat message\n          let messageData = {\n            content: c,\n            user: game.user._id,\n            speaker: ChatMessage.getSpeaker({ user: game.user }),\n            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n          };\n          messageData = ChatMessage.applyRollMode(messageData, game.settings.get(\"core\", \"rollMode\"));\n          ChatMessage.create(messageData);\n        },\n      },\n    },\n  }).render(true);\n}","author":"61klraqiWb97OOLa","img":"systems/ffd20/icons/skills/red_25.jpg","actorIds":[],"_id":"NozVDiFkfZcBg4Hg"}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","type":"script","scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    for (let a = 0; a < actors.length; a++) {\n      let o = actors[a];\n      await o.rollSavingThrow(type, { event: new MouseEvent({}), noSound: a > 0, });\n    }\n  };\n\n  const msg = `Choose a saving throw to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Fortitude\",\n        callback: () => _roll(\"fort\"),\n      },\n      ref: {\n        label: \"Reflex\",\n        callback: () => _roll(\"ref\"),\n      },\n      will: {\n        label: \"Will\",\n        callback: () => _roll(\"will\"),\n      },\n    },\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/diehard.jpg","actorIds":[]}
{"_id":"ccZmfabwQrONq2kg","name":"Toggle Buff","type":"script","scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n  buffName: \"Mage Armor\"\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  for (let actor of actors) {\r\n    const buff = actor.items.find(o => o.name === c.buffName && o.type === \"buff\");\r\n    if (buff != null) {\r\n      let active = getProperty(buff.data, \"data.active\");\r\n      if (active == null) active = false;\r\n      buff.update({ \"data.active\": !active });\r\n    }\r\n  }\r\n}\r\n","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/spells/protect-blue-1.jpg","actorIds":[]}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","type":"script","scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    let madeSound = false;\n    for (let a = 0;a < actors.length; a++) {\n      let o = actors[a];\n      let info = o.getSkillInfo(type);\n      if (!info) continue;\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true, noSound: madeSound, });\n      madeSound = true;\n    }\n  };\n\n  const buttons = c.skills.reduce((cur, s) => {\n    let info;\n    for (let o of actors) {\n      info = o.getSkillInfo(s);\n      if (info) break;\n    }\n    if (!info) return cur;\n    let label = info.name;\n    cur[s] = {\n      label: label,\n      callback: () => _roll(s),\n    };\n    return cur;\n  }, {});\n\n  const msg = `Choose a skill to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: buttons,\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/skill-focus.jpg","actorIds":[]}
{"_id":"yEPv1InFUHWnh1kt","name":"Create Loot Sheets","type":"script","scope":"global","command":"// CONFIGURATION\n/**\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.ENTITY_PERMISSIONS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\n */\n\nconst c = {\n    folder: \"Misc/Loot\",\n    defaultPermission: CONST.ENTITY_PERMISSIONS.OBSERVER,\n    sheetType: \"FFD20.ActorSheetPFNPCLoot\",\n};\n\n// END CONFIGURATION\n\n(async () => {\n\n    // Get selected tokens\n    let tokens = canvas.tokens.controlled;\n    if (!tokens.length) return;\n\n    // Create folder(s)\n    let lastFolder = null;\n    let lastIndex = 0;\n    if (c.folder) {\n        const folders = game.folders.filter(f => f.type === \"Actor\");\n        const folderNames = c.folder.split(\"/\");\n        for (let a = 0; a < folderNames.length; a++) {\n            let curName = folderNames[a];\n            let prevName = a > 0 ? folderNames[a-1] : null;\n            \n            const f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\n            if (f) {\n                lastFolder = f;\n                lastIndex = a+1;\n            }\n        }\n\n        for (let a = lastIndex; a < folderNames.length; a++) {\n            const newFolder = await Folder.create({\n                name: folderNames[a],\n                parent: lastFolder ? lastFolder._id : null,\n                type: \"Actor\",\n            });\n            lastFolder = newFolder;\n        }\n    }\n\n    // Gather currency\n    let [pp, gp, sp, cp] = tokens.reduce((cur, t) => {\n        cur[0] += t.actor.data.data.currency.pp;\n        cur[1] += t.actor.data.data.currency.gp;\n        cur[2] += t.actor.data.data.currency.sp;\n        cur[3] += t.actor.data.data.currency.cp;\n        return cur;\n    }, [0, 0, 0, 0]);\n\n    // Create loot NPC for selected tokens\n    const lootName = \"(Loot) \" + tokens.reduce((cur, o) => {\n        cur.push(o.name);\n        return cur;\n    }, []).join(\", \");\n    const lootNPC = await Actor.create({\n        name: lootName,\n        type: \"npc\",\n        img: tokens[0].actor.img,\n        folder: lastFolder ? lastFolder._id : null,\n        permission: {\n            default: c.defaultPermission,\n        },\n        flags: {\n            core: {\n                sheetClass: c.sheetType,\n            },\n        },\n        data: {\n            currency: {\n                pp: pp,\n                gp: gp,\n                sp: sp,\n                cp: cp,\n            },\n        },\n    });\n\n    // Gather item data\n    const itemData = tokens.reduce((cur, o) => {\n        for (let i of o.actor.items) {\n            if (game.ffd20.ItemPF.isInventoryItem(i.type) && i.data.data.quantity > 0) {\n                // Check for identical data\n                let addRaw = true;\n                let firstItem;\n                for (let i2 of cur) {\n                    if (i2.name === i.name) {\n                        firstItem = i2;\n                        addRaw = false;\n                        const diffData = flattenObject(diffObject(i.data.data, i2.data));\n                        for (let k of Object.keys(diffData)) {\n                            if (![\"quantity\"].includes(k)) addRaw = true;\n                        }\n                    }\n                }\n                if (addRaw) {\n                    cur.push(duplicate(i.data));\n                }\n                else {\n                    firstItem.data.quantity += i.data.data.quantity;\n                }\n            }\n        }\n        return cur;\n    }, []);\n    \n    // Add items\n    await lootNPC.createOwnedItem(itemData);\n\n})();","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/items/inventory/chest-light.jpg","actorIds":[]}
